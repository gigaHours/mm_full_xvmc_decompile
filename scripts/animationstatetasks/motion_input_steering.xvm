module motion_input_steering

def Enter(self, arg1):
    pass

def InRotationSegment(self, arg1):
    return lib_character.SegmentNonExistentOrWithin(self, @E063F6A0, game.GameHashFloat(arg1))

def Exit(self, arg1):
    if InRotationSegment(self, arg1.Segment):
        local2 = character.GetWorldMatrix(self)
        local3 = vector.Scale(local2.r2, -1.0)
        local4 = arg1.HighAngularSpeed
        local5 = arg1.HighAngularAcc
        character.RotateToward(self, local3, local4, local5)

def Update(self, arg1, arg2):
    if InRotationSegment(self, arg1.Segment):
        local3 = input.GetFilteredMoveInput()
        local4 = vector.Length(local3)
        local5 = lib_character.GetFilteredMoveInputWorldDir()
        local6 = 0.0
        local7 = 0.0
        if local4 > arg1.HighThreshold:
            local6 = arg1.HighAngularSpeed
            local7 = arg1.HighAngularAcc
        elif arg1.HighThreshold > local4:
            local6 = arg1.LowAngularSpeed
            local7 = arg1.LowAngularAcc
        else:
            local6 = math.Scale(local4, arg1.HighThreshold, arg1.HighThreshold, arg1.LowAngularSpeed, arg1.HighAngularSpeed)
            local7 = math.Scale(local4, arg1.HighThreshold, arg1.HighThreshold, arg1.LowAngularAcc, arg1.HighAngularAcc)
        if not arg1.LerpedMaxAngularAcc:
            arg1.LerpedMaxAngularAcc = local7
        arg1.LerpedMaxAngularAcc = math.SpeedLerp(arg1.LerpedMaxAngularAcc, local7, arg1.AccLerpSpeed, arg2)
        character.RotateToward(self, local5, local6, arg1.LerpedMaxAngularAcc)
