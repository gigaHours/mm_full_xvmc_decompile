module vpaerodynamics
import @F76070AE
import @58351C01
import @B79BE9DF
import @45098D7D

def UpdateAerodynamics(self, arg1, arg2):
    arg1.CenterOfMassTorque = vector.Set(0.0, 0.0, 0.0, 0.0)
    local3 = arg1.VehicleGameObject
    local4 = game.GetTransform(local3)
    local5 = arg1.WorldGroundUp
    local6 = matrix.DirectionWorldToLocal(local4, local5)
    local7 = vehicle.VectorToSAE(local6)
    local8 = arg1.LinearVelocity
    local9 = vector.Scale(local7, vector.Dot(local8, local7))
    local8 = vector.Sub(local8, local9)
    local10 = SquareVelocityComponents(local8)
    local11 = AeroDrag(arg1, local8, local10, false)
    if vector.Length(local8) > 0.0:
        arg1.CenterOfMassForce = vector.Scale(vector.Normalize(local8), -local11)
    else:
        arg1.CenterOfMassForce = vector.Set(0.0, 0.0, 0.0, 0.0)
    local12 = arg1.LinearVelocity
    local10 = SquareVelocityComponents(local12)
    local13 = arg1.FrontLiftCdA
    local14 = arg1.RearLiftCdA
    local15 = 0.5 * 1.2041 * vector.Dot(local13, local10)
    local16 = 0.5 * 1.2041 * vector.Dot(local14, local10)
    local17 = arg1.Axles
    local17[0.0].Force = vector.Set(0.0, 0.0, -local15, 0.0)
    local17[1.0].Force = vector.Set(0.0, 0.0, -local16, 0.0)
    local18 = vehicle.GetTweakVariables()
    if local18.MARIO_GRAVITY:
        if 0.0 >= vehicle.GetWheelContactRatio(local3) and arg1.LinearVelocity.z >= 0.0:
            arg1.CenterOfMassForce = vector.Add(arg1.CenterOfMassForce, vector.Set(0.0, 0.0, arg1.Mass * 9.81 * local18.MARIO_GRAVITY_SCALE, 0.0))
    if vehicle.GetWheelContactRatio(local3) == 0.0 and (not lib_vehicle.ShouldRelaxHelpers(local3)):
        local19 = arg1.Inertia
        local20 = arg1.AngularVelocity
        local21 = arg1.LinearVelocity
        local22 = (arg1.Brake - arg1.Throttle) * 0.35
        local23 = -math.ASin(local4.r0.y)
        local24 = -math.ASin(local4.r2.y)
        if local22 > 0.0:
            local25 = math.Clamp(local22 + local24, 0.0, 0.35)
        elif 0.0 > local22:
            local25 = math.Clamp(local22 + local24, -0.35, 0.0)
        else:
            local25 = math.Clamp(local24, -0.35, 0.35)
        local26 = 2.0 * math.Pi() * 0.2
        local27 = math.Clamp(local19.x, 0.0, 100000.0)
        local28 = math.Clamp(local19.y, 0.0, 100000.0)
        local29 = local26 * local26 * local27
        local30 = local26 * local26 * local28
        local31 = 1.0 * 2.0 * math.Sqrt(local29 * local27)
        local32 = 1.0 * 2.0 * math.Sqrt(local30 * local28)
        local33 = local4.r1.y
        if 0.0 > local33:
            local34 = local29 * local23
            local35 = 0.0
        else:
            local34 = local29 * local23 + local31 * local20.x
            local35 = local30 * local25 + local32 * local20.y
        arg1.CenterOfMassTorque = vector.Set(-local34 * local33, -local35, 0.0, 0.0)
    else:
        arg1.CenterOfMassTorque = vector.Set(0.0, 0.0, 0.0, 0.0)
    if vehicle.IsPlayerVehicle(local3):
        pass

def External_AeroDrag(self, arg1, arg2):
    local3 = vehicle.GetChassis(arg1)
    local4 = SquareVelocityComponents(arg2)
    return AeroDrag(local3, arg2, local4, true)

def UpdateSuperSteer(self, arg1, arg2):
    local3 = arg1.Wheels
    local4 = len(local3)
    local5 = 0.0
    local6 = 0.0
    local8 = 0.0
    local9 = 1.0
    local7 = local4
    while local7 > local8:
        local10 = local3[local8]
        if local10.Steered and local10.Load > 0.0:
            local6 = local6 + local10.SteeringAngle
            local5 = local5 + 1.0
        local8 = local9 + local8
    if local5 == 0.0:
        return
    local6 = local6 / (2.0 * local5)
    local11 = matrix.RotationAxisMatrix(vector.Set(0.0, 1.0, 0.0, 0.0), local6)
    local12 = arg1.LinearVelocity
    local12.z = 0.0
    local13 = vector.Length(local12)
    if local12.x > 0.0:
        local13 = local13 * -1.0
    local14 = vehicle.VectorToSAE(vector.Scale(local11.r2, local13))
    local15 = vector.Sub(local14, local12)
    local16 = vector.Scale(local15, arg1.SuperSteerScale * arg1.Mass / arg2)
    arg1.CenterOfMassForce = vector.Add(arg1.CenterOfMassForce, local16)

def UpdateTurtle(self, arg1, arg2):
    local3 = arg1.VehicleGameObject
    local4 = vehicle.GetWheelContactRatio(local3)
    local5 = lib_vehicle.ShouldRelaxHelpers(local3)
    if local5:
        local6 = vehicle.GetHealth(local3) > 0.0 or vehicle.IsSignatureVehicle(local3)
        if not local6:
            return
        local7 = vector.Length(arg1.LinearVelocity)
        local8 = vector.Length(arg1.AngularVelocity)
        local9 = local7 * local7 + local8 * local8
        local10 = 0.5 >= local4 and 5.0 * 5.0 > local9
        if not local10:
            return
    if local5:
        local11 = 0.4
    else:
        local11 = 0.2
    local12 = 2.0
    local13 = 0.1
    local14 = 2.0
    if local4 == 0.0 or local5:
        local13 = 0.0
    local15 = game.GetTransform(local3)
    local16 = local15.r0
    local17 = local15.r1
    local18 = local15.r2
    local19 = local15.r3
    local20 = arg1.WorldGroundUp
    local21 = vector.Cross(local20, local18)
    local21 = vector.Normalize(local21)
    local22 = vector.Cross(local16, local20)
    local22 = vector.Normalize(local22)
    local23 = vector.Dot(local16, local21) - 1.0
    if 0.5 > math.Abs(local23):
        local11 = 0.0
    if vector.Dot(local16, local20) > 0.0:
        local23 = local23 * -1.0
    local24 = vector.Dot(local18, local22) - 1.0
    if 0.5 > math.Abs(local24):
        local13 = 0.0
    if local24 > 0.0:
        local24 = 0.0
    if -1.0 > local24:
        local24 = 0.0
    if vector.Dot(local18, local20) > 0.0:
        local24 = local24 * -1.0
    local25 = arg1.AngularVelocity.x
    local26 = arg1.AngularVelocity.y
    local27 = local12 * local23
    if 0.0 > local23 and local27 >= local25:
        local27 = local25
    if local23 >= 0.0 and local25 >= local27:
        local27 = local25
    local28 = local14 * local24
    if 0.0 > local24 and local28 >= local26:
        local28 = local26
    if local24 >= 0.0 and local26 >= local28:
        local28 = local26
    local29 = (local27 - local25) / arg2
    local30 = (local28 - local26) / arg2
    local31 = local11 * local29 * arg1.Inertia.x
    local32 = local13 * local30 * arg1.Inertia.y
    arg1.CenterOfMassTorque = vector.Add(arg1.CenterOfMassTorque, vector.Set(local31, local32, 0.0, 0.0))

def SquareVelocityComponents(self):
    local1 = vector.Set(self.x * self.x, self.y * self.y, self.z * self.z, 0.0)
    return local1

def AeroDrag(self, arg1, arg2, arg3):
    local4 = 1.0
    local5 = self.AeroSpeedCap
    if arg1.x > local5 and self.Drivetrain.BoostTorque == 0.0:
        local4 = 1.0 + 1.0 * (arg1.x - local5)
    local6 = self.DragCdA
    local6.z = local6.y
    local7 = 0.5 * 1.2041 * vector.Dot(local6, arg2)
    if not arg3:
        local8 = self.VehicleGameObject
        if vehicle.IsPlayerVehicle(local8):
            local9 = vehicle.GetGlobalProperties()
            if local9.ldSpeedLimit:
                if arg1.x > local9.ldSpeedLimit:
                    local10 = arg1.x - local9.ldSpeedLimit
                    return local4 * local7 + vehicle.GetMass(local8) * local10 * local10
    return local4 * local7
