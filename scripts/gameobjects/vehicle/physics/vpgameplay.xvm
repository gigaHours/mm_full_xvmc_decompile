module vpgameplay
import @45098D7D

def External_EvaluateBoostForce(self, arg1, arg2):
    local3 = 0.0
    if arg1 != 0.0:
        local3 = math.Sqrt(arg1)
    local4 = arg2 / 3.2
    return local4

def UpdateBoost(self, arg1):
    local2 = self.Drivetrain
    local3 = self.VehicleGameObject
    if local2.BoostTorque != 0.0:
        local4 = math.Abs(vehicle.GetLocalVelocity(local3).z)
        local5 = 0.0
        if local4 != 0.0:
            local5 = math.Sqrt(local4)
        local6 = local2.BoostTorque
        local7 = local6 / 3.2
        local8 = game.GetTransform(local3)
        local9 = vector.Scale(local8.r2, -1.0)
        local10 = vehicle.GetCenterOfMass(local3)
        local11 = vehicle.GetWheelContactRatio(local3)
        if local11 > 0.5 and local7 > 0.0:
            local12 = math.Scale01(local5, 0.0, 7.07)
            local10 = vector.Add(local10, vector.Set(0.0, math.Lerp(local12, -0.5, -0.25), 0.0, 0.0))
        if local11 > 0.5:
            local13 = matrix.DirectionLocalToWorld(local8, vector.Set(0.0, -1.0, 0.0, 0.0))
            physics.ApplyImpulse(local3, vector.Scale(local13, vehicle.GetMass(local3) * 9.81 * arg1), local10)
        physics.ApplyImpulse(local3, vector.Scale(local9, local7 * arg1), local10)

def ScaleInOutNeg(self, arg1, arg2, arg3, arg4):
    if arg2 > self:
        return math.Clamp01((self - arg1) / (arg2 - arg1)) - 1.0
    if self > arg3:
        return math.Clamp01((self - arg3) / (arg4 - arg3))
    return 0.0

def UpdateRamRecovery(self, arg1, arg2):
    local3 = arg1.VehicleGameObject
    local4 = scriptgo.GetProperties(self)
    local5 = game.GetTransform(local3)
    local6 = local5.r3
    local7 = debug.GetTweakVariables()
    local7.SET_VELOCITY_ON_IMPACT = ["Tweak|Vehicle|AI|Set Velocity On Impact", true]
    if local7.SET_VELOCITY_ON_IMPACT:
        local8 = ai.GetAiEntityBlackboardFlag(local3, "is_ramming")
        if local8:
            local9 = vehicle.GetHitInfo(local3)
            if local9:
                local10 = vehicle.GetGameObject(local9)
                if local10:
                    if vehicle.IsVehicle(local10) and vehicle.IsPlayerVehicle(local10) and local4.recovery_time == none:
                        local4.recovery_time = 1.0
                        local4.recovery_vel = vehicle.GetVelocity(local10)
                        local4.recovery_obj = local10
        if local4.recovery_time:
            local11 = local4.recovery_obj
            if not local11:
                local4.recovery_time = none
            else:
                local12 = local4.recovery_time
                local13 = game.GetTransform(local11)
                local14 = vector.Scale(local13.r2, -1.0)
                local15 = vehicle.GetVelocity(local11)
                local16 = local4.recovery_vel
                local17 = vector.Length(local16)
                local18 = vector.Scale(local16, 1.0 / local17)
                local19 = vehicle.GetCenterOfMass(local3)
                local20 = vehicle.GetVelocity(local3)
                local21 = vector.Scale(local5.r2, -1.0)
                local22 = vector.Dot(local20, local18)
                local23 = false
                local24 = vector.AngleBetween(local21, local18)
                if local17 > vector.Length(local15) + 10.0:
                    local23 = true
                if local24 > 0.78:
                    local23 = true
                local25 = vector.AngleBetween(local14, local18)
                if local25 > 1.0:
                    local23 = true
                local26 = local17 - local22
                if 0.0 > local26:
                    local23 = true
                local9 = vehicle.GetHitInfo(local3)
                if local9:
                    local10 = vehicle.GetGameObject(local9)
                    if local10:
                        if not vehicle.IsVehicle(local10):
                            local27 = vehicle.GetOtherNormal(local9)
                            if 0.78 > math.Abs(local27.y):
                                local23 = true
                if local23:
                    local4.recovery_time = none
                else:
                    local28 = vehicle.GetWheelContactRatio(local3)
                    if local28 >= 0.5:
                        local29 = vehicle.GetMass(local3)
                        local30 = 10.0 * (local17 - local22) * local29 * arg2
                        physics.ApplyImpulse(local3, vector.Scale(local18, local30), local19)
                    local12 = local12 - arg2
                    if local12 > 0.0:
                        local4.recovery_time = local12
                    else:
                        local4.recovery_time = none

def InitTurtleRam(self, arg1):
    arg1.turtle_reaction_time = 0.0
    arg1.turtle_side_hit_react = false
    local2 = debug.GetTweakVariables()
    local2.TURTLE_RAM_COOLDOWN = ["Tweak|Vehicle|Side Ram|Cooldown", 0.5, 0.1]
    local2.TURTLE_RAM_TIME = ["Tweak|Vehicle|Side Ram|Time", 0.32, 0.01]
    local2.TURTLE_RAM_ACC = ["Tweak|Vehicle|Side Ram|Acceleration", 100.0, 1.0]
    local2.TURTLE_RAM_Z_SCALE = ["Tweak|Vehicle|Side Ram|Z Scale", 4.0, 0.1]
    local2.TURTLE_RAM_ENEMY_DISTANCE = ["Tweak|Vehicle|Side Ram|Enemy Distance", 12.0, 1.0]
    local2.TURTLE_RAM_ENEMIES_REQUIRED = ["Tweak|Vehicle|Side Ram|Require Nearby Enemies", false]
    local2.TURTLE_RAM_OFFSET_IN = ["Tweak|Vehicle|Side Ram|Movement fade in", 0.05, 0.1]
    local2.TURTLE_RAM_OFFSET_OUT = ["Tweak|Vehicle|Side Ram|Movement fade out", 0.15, 0.1]
    local2.TURTLE_RAM_FADE_IN_FORCE_SCALE = ["Tweak|Vehicle|Side Ram|Movement fade in force scale", 1.0, 0.1]
    local2.TURTLE_RAM_FADE_OUT_FORCE_SCALE = ["Tweak|Vehicle|Side Ram|Movement fade out force scale", 0.7, 0.1]
    local2.TURTLE_RAM_STEERING_FADE_IN_START = ["Tweak|Vehicle|Side Ram|Steering fade in start", 0.01, 0.1]
    local2.TURTLE_RAM_STEERING_FADE_IN = ["Tweak|Vehicle|Side Ram|Steering fade in", 0.15, 0.1]
    local2.TURTLE_RAM_SPEED_SCALE_MIN = ["Tweak|Vehicle|Side Ram|Speed scale min", 4.0, 0.1]
    local2.TURTLE_RAM_SPEED_SCALE_MAX = ["Tweak|Vehicle|Side Ram|Speed scale max", 25.0, 0.1]
    local2.TURTLE_RAM_WEIGHT_SCALE_MIN = ["Tweak|Vehicle|Side Ram|Weight scale min", -850.0, 10.0]
    local2.TURTLE_RAM_WEIGHT_SCALE_MAX = ["Tweak|Vehicle|Side Ram|Weight scale max", 18000.0, 10.0]
    local2.TURTLE_RAM_IMPACT_SCALE = ["Tweak|Vehicle|Side Ram|Impact Scale", 5.0, 0.1]
    local2.TURTLE_RAM_PLAYER_IMPACT_SCALE = ["Tweak|Vehicle|Side Ram|Impact Player Scale", 0.0, 0.1]
    local2.TURTLE_RAM_UPWARD_IMPACT_SCALE = ["Tweak|Vehicle|Side Ram|Impact Upward Scale", 6.3, 0.1]
    local2.TURTLE_RAM_REACTION_TIME = ["Tweak|Vehicle|Side Ram|Reaction Time", 0.1, 0.1]

def UpdateFallTracking(self, arg1):
    local2 = self.VehicleGameObject
    local3 = vehicle.GetProperties(local2)
    local4 = vehicle.GetWheelContactRatio(local2)
    if local4 == 0.0:
        if not local3.airTime:
            local3.airTime = arg1
        else:
            local3.airTime = local3.airTime + arg1
        local5 = vehicle.SAEToVector(self.CenterOfMassPosition)
        local6 = matrix.MulVec(game.GetTransform(local2), local5)
        if not local3.fallHigh:
            local3.fallHigh = local6.y
        elif local6.y > local3.fallHigh:
            local3.fallHigh = local6.y
    elif local4 == 1.0:
        local3.fallHigh = none
        local3.airTime = 0.0

def UpdatePlayerDialogue(self, arg1, arg2):
    if vehicle.IsSignatureVehicle(arg1.VehicleGameObject):
        UpdateInAirDialogue(self, arg1, arg2)
        UpdateDonutDialogue(self, arg1, arg2)
        UpdateHandbreakTurnDialogue(self, arg1, arg2)
        UpdateTopspeedDialogue(self, arg1, arg2)

def OnPlayerExitGameplay(self, arg1):
    local2 = scriptgo.GetProperties(self)
    ExitCruiseMode(arg1, local2)

def UpdateTurtleRam(self, arg1, arg2):
    local3 = input.GetButtonInput(@677A49E9) > 0.0
    local4 = input.GetLeftStickInput().x
    local5 = self.VehicleGameObject
    local6 = game.GetTransform(local5)
    local7 = vehicle.GetCenterOfMass(local5)
    local8 = vehicle.GetVelocity(local5)
    local9 = vehicle.GetMass(local5)
    local10 = vehicle.GetWheelContactRatio(local5)
    local11 = math.Min(local9, arg1.sideram_clamp_mass)
    local12 = debug.GetTweakVariables()
    if arg1.turtle_ram_time_since_ram != none:
        arg1.turtle_ram_time_since_ram = arg1.turtle_ram_time_since_ram + arg2
        if 0.15 > arg1.turtle_ram_time_since_ram:
            local13 = math.Scale01(arg1.turtle_ram_time_since_ram, 0.01, 0.15)
            self.SteeringInput = self.SteeringInput * local13
        else:
            arg1.turtle_ram_time_since_ram = none
            local14 = lib_entity_proxy.GetCollision(local5)
            scriptgo.Call1(local14, @885E0BBC, true)
    if arg1.turtle_ram_wait_release:
        if local3:
            local3 = false
        else:
            arg1.turtle_ram_wait_release = none
    if arg1.turtle_ram_cooldown:
        if arg1.turtle_ram_cooldown > 0.0:
            arg1.turtle_ram_cooldown = arg1.turtle_ram_cooldown - arg2
            return
    if 0.5 >= local10:
        local3 = false
    local15 = vector.Normalize(local8)
    local16 = vector.Dot(local15, local6.r2)
    if local16 > -0.9:
        local3 = false
    if local12.TURTLE_RAM_ENEMIES_REQUIRED:
        if vehicle.GetNbVehicleEnemies(local7, local12.TURTLE_RAM_ENEMY_DISTANCE) == 0.0:
            local3 = false
    if not arg1.turtle_ram_active:
        if local3:
            arg1.turtle_ram_wait_dir = true
            arg1.turtle_ram_time = 0.0
            arg1.turtle_ram_side = 0.0
    if arg1.turtle_ram_wait_dir:
        if not local3:
            arg1.turtle_ram_wait_dir = false
        elif math.Abs(local4) > 0.1:
            arg1.turtle_ram_active = true
            local14 = lib_entity_proxy.GetCollision(local5)
            scriptgo.Call1(local14, @885E0BBC, false)
            arg1.turtle_ram_wait_dir = false
            arg1.turtle_ram_side = math.Sign(local4)
            arg1.turtle_ram_dir = local6.r0
            local17 = vector.Length(local8)
            local18 = math.Scale01(local17, local12.TURTLE_RAM_SPEED_SCALE_MIN, local12.TURTLE_RAM_SPEED_SCALE_MAX)
            arg1.turtle_ram_blend_factor = local18
            arg1.turtle_ram_acc = local18 * local12.TURTLE_RAM_ACC
            vehicle.SetSideRamAttackEnabled(self.VehicleGameObject, true, arg1.turtle_ram_side)
    if arg1.turtle_ram_active:
        local19 = vehicle.GetHitInfo(local5)
        local20 = false
        local21 = ScaleInOutNeg(arg1.turtle_ram_time, 0.0, local12.TURTLE_RAM_OFFSET_IN, local12.TURTLE_RAM_TIME - local12.TURTLE_RAM_OFFSET_OUT, local12.TURTLE_RAM_TIME)
        if local19:
            local22 = vehicle.GetGameObject(local19)
            if local22:
                if vehicle.IsVehicle(local22) and arg1.turtle_victim == none:
                    local23 = game.GetTransform(local22)
                    local24 = vector.Sub(local6.r3, local23.r3)
                    local24 = vector.Normalize(local24)
                    local25 = vector.Dot(local24, local6.r0)
                    if math.Sign(local25) == arg1.turtle_ram_side:
                        if arg1.turtle_ram_blend_factor > 0.35:
                            if not vehiclemanager.IsComboActive(@F5F03835):
                                vehiclemanager.StartCombo(@F5F03835)
                                arg1.turtle_combo_prev_target = local22
                                arg1.turtle_combo_prev_side = arg1.turtle_ram_side
                            elif (not game.IsObjectEqualTo(arg1.turtle_combo_prev_target, local22)) and arg1.turtle_combo_prev_side != arg1.turtle_ram_side:
                                arg1.turtle_combo_prev_target = local22
                                arg1.turtle_combo_prev_side = arg1.turtle_ram_side
                                vehiclemanager.ProgressCombo(@F5F03835)
                            elif vehiclemanager.GetComboProgress(@F5F03835) == 0.0:
                                vehiclemanager.StartCombo(@F5F03835)
                                arg1.turtle_combo_prev_target = local22
                                arg1.turtle_combo_prev_side = arg1.turtle_ram_side
                        arg1.turtle_victim_hitpos = matrix.PositionWorldToLocal(local23, vehicle.GetPosition(local19))
                        arg1.turtle_victim = local22
                        arg1.turtle_victim_hit_scale = local21
                        arg1.turtle_victim_hit_transform = local6
                        arg1.turtle_victim_hit_acc = arg1.turtle_ram_acc
                        arg1.turtle_hit_my_velocity = vehicle.GetHitSelfVelocity(local19)
                        arg1.turtle_hit_victim_velocity = vehicle.GetHitOtherVelocity(local19)
                        local26 = vector.Normalize(local6.r2)
                        local27 = vector.Normalize(local23.r2)
                        arg1.turtle_victim_dot_strength = math.Abs(vector.Dot(local26, local27))
                        arg1.turtle_reaction_time = local12.TURTLE_RAM_REACTION_TIME
                        arg1.turtle_side_hit_react = true
        if (not local20) and (not arg1.turtle_side_hit_react):
            local28 = 1.0
            if 0.0 > local21:
                local28 = local12.TURTLE_RAM_FADE_IN_FORCE_SCALE
            if local21 > 0.0:
                local28 = local12.TURTLE_RAM_FADE_OUT_FORCE_SCALE
            local29 = math.Scale01(local9, local12.TURTLE_RAM_WEIGHT_SCALE_MIN, local12.TURTLE_RAM_WEIGHT_SCALE_MAX)
            local30 = local12.TURTLE_RAM_Z_SCALE * local21 * local29
            local31 = vector.Add(local7, vector.Scale(local6.r2, local30))
            local32 = -arg1.turtle_ram_side * arg1.turtle_ram_acc * local11 * local28 * arg2 * local10
            local33 = vector.Scale(local6.r0, local32)
            physics.ApplyImpulse(local5, local33, local31)
            local34 = 1.0 - math.Abs(ScaleInOutNeg(arg1.turtle_ram_time, 0.0, local12.TURTLE_RAM_TIME / 2.0, local12.TURTLE_RAM_TIME / 2.0, local12.TURTLE_RAM_TIME))
            local13 = arg1.turtle_ram_blend_factor * local34
            local35 = self.Axles
            local36 = len(local35)
            local38 = 0.0
            local39 = 1.0
            local37 = local36
            while local37 > local38:
                local40 = local35[local38]
                if local40.Steered:
                    local40.LeftWheel.VisualSteeringAngle = math.Clamp(-arg1.turtle_ram_side * local13 * 0.22, -self.MaxSteeringAngle, self.MaxSteeringAngle)
                    local40.RightWheel.VisualSteeringAngle = math.Clamp(-arg1.turtle_ram_side * local13 * 0.22, -self.MaxSteeringAngle, self.MaxSteeringAngle)
                    local40.LeftWheel.SteeringAngle = 0.0
                    local40.RightWheel.SteeringAngle = 0.0
                local38 = local39 + local38
            self.SteeringInput = 0.0
        arg1.turtle_ram_time = arg1.turtle_ram_time + arg2
        if local20 or arg1.turtle_ram_time > local12.TURTLE_RAM_TIME:
            arg1.turtle_ram_active = false
            arg1.turtle_ram_wait_dir = false
            arg1.turtle_side_hit_react = false
            arg1.turtle_ram_wait_release = true
            arg1.turtle_ram_time = none
            arg1.turtle_victim = none
            arg1.turtle_victim_hitpos = none
            arg1.turtle_ram_cooldown = local12.TURTLE_RAM_COOLDOWN
            arg1.turtle_ram_time_since_ram = 0.0
            vehicle.SetSideRamAttackEnabled(self.VehicleGameObject, false, 0.0)
    if arg1.turtle_reaction_time > 0.0 and arg1.turtle_side_hit_react:
        arg1.turtle_reaction_time = arg1.turtle_reaction_time - arg2
        UpdateSideramReaction(self, arg1, arg2, local11, local7)

def InitDialogueData(self):
    local1 = scriptgo.GetProperties(self)
    local1.in_air_time = 0.0
    local1.donut_time = 0.0
    local1.handbrake_time = 0.0
    local1.handbrake_timeout = 0.0

def UpdateHandbreakTurnDialogue(self, arg1, arg2):
    local3 = arg1.VehicleGameObject
    local4 = scriptgo.GetProperties(self)
    if local4.handbrake_timeout > 0.0:
        local4.handbrake_timeout = local4.handbrake_timeout - arg2
    else:
        local5 = vehicle.GetHandbrakeInput(local3) > 0.0
        local6 = math.Abs(vehicle.GetLocalAngularVelocity(local3).y)
        local7 = vector.Length(vehicle.GetLocalVelocity(local3))
        if local5:
            local4.handbrake_time = 0.8
        elif local4.handbrake_time > 0.0:
            local4.handbrake_time = local4.handbrake_time - arg2
        if local4.handbrake_time > 0.0 and local7 > 10.0 and local6 > 1.2:
            local4.handbrake_timeout = 5.0
            scriptgo.SendEvent(self, @FF4F6725)

def UpdateInAirDialogue(self, arg1, arg2):
    local3 = scriptgo.GetProperties(self)
    local4 = arg1.VehicleGameObject
    if not vehicle.IsSignatureVehicle(local4):
        return
    local5 = vehicle.GetWheelContactRatio(local4)
    if 0.0 >= local5:
        local3.in_air_time = local3.in_air_time + arg2
    else:
        local3.in_air_time = 0.0
    if local3.in_air_time > 0.0:
        local6 = vehicle.GetLocalVelocity(local4)
        local7 = vehicle.GetVelocity(local4)
        if local3.in_air_time > 0.4 and -20.0 > local6.z and math.Abs(local7.z) > 15.0:
            scriptgo.SendEvent(self, @39EF32B0)
        local8 = 0.7
        local9 = 5.0
        if local3.in_air_time > local8 and -local9 > local7.y:
            scriptgo.SendEvent(self, @F58DDEB7)

def UpdateDonutDialogue(self, arg1, arg2):
    local3 = arg1.VehicleGameObject
    local4 = lib_vehicle.InDonut(local3)
    local5 = scriptgo.GetProperties(self)
    if local4:
        local6 = local5.donut_time
        local5.donut_time = local5.donut_time + arg2
        if local5.donut_time > 6.0 and 6.0 > local6:
            local5.donut_time = 0.0
            scriptgo.SendEvent(self, @8F5862BD)
    else:
        local5.donut_time = 0.0

def UpdateAIGameplay(self, arg1, arg2):
    UpdateFallTracking(arg1, arg2)
    UpdateBoost(arg1, arg2)
    UpdateAIBoost(arg1, arg2)
    UpdateRollOverDamage(arg1.VehicleGameObject)
    UpdateDeformationGameplay(self, arg1, arg2)
    UpdateComboDetection(self, arg1, arg2)
    UpdateRamRecovery(self, arg1, arg2)

def ExitCruiseMode(self, arg1):
    local2 = self.Wheels
    local3 = arg1.prev_cruiseroughness
    if local3 > 0.0:
        vehicle.SendVehicleSoundEvent(self.VehicleGameObject, @4DE1B469)
        vehiclemanager.SendVehicleCruiseSpeedEvent(self.VehicleGameObject, arg1.cruise_speed_duration, arg1.cruise_speed_best_speed, arg1.cruise_speed_distance)
    arg1.prev_cruiseroughness = 0.0
    arg1.cruise_speed_best_speed = 0.0
    arg1.cruise_speed_duration = 0.0
    arg1.cruise_speed_distance = 0.0
    local5 = 0.0
    local6 = 1.0
    local4 = 4.0
    while local4 > local5:
        local2[local5].ExtraChassisForce = vector.Set(0.0, 0.0, 0.0, 0.0)
        local5 = local6 + local5

def InitCruiseMode(self):
    self.cruisePhase = [vector.Set(0.0, 0.0, 0.0, 0.0), vector.Set(0.0, 0.0, 0.0, 0.0), vector.Set(0.0, 0.0, 0.0, 0.0), vector.Set(0.0, 0.0, 0.0, 0.0)]
    self.prev_cruiseroughness = 0.0
    self.cruise_speed_best_speed = 0.0
    self.cruise_speed_duration = 0.0
    self.cruise_speed_distance = 0.0

def PreInit(self):
    local1 = scriptgo.GetProperties(self)
    InitCruiseMode(local1)
    InitTurtleRam(self, local1)
    InitDialogueData(self)
    InitDeform(self)

def fmod(self, arg1):
    return self - math.Floor(self / arg1) * arg1

def UpdateSideramReaction(self, arg1, arg2, arg3, arg4):
    local5 = arg1.turtle_victim
    if local5 != none:
        local6 = game.GetTransform(local5)
        local7 = matrix.PositionLocalToWorld(local6, arg1.turtle_victim_hitpos)
        local8 = self.VehicleGameObject
        local9 = arg1.turtle_victim_hit_transform
        local10 = debug.GetTweakVariables()
        local11 = vector.Set(1.0, 1.0, 1.0, 1.0)
        local12 = vehicle.GetCenterOfMass(local5)
        local13 = math.Min(vehicle.GetMass(local5), 3000.0)
        local14 = 1.0 - math.Abs(math.Max(arg1.turtle_victim_hit_scale, -0.4))
        local15 = arg1.turtle_victim_hit_acc / local10.TURTLE_RAM_ACC
        if vehicle.GetHealth(local5) > 0.0:
            local16 = -arg1.turtle_ram_side * local15 * local14 * local10.TURTLE_RAM_IMPACT_SCALE * local13 * arg1.turtle_victim_dot_strength * arg2
            local17 = vector.Scale(local9.r0, local16)
            physics.ApplyImpulse(local5, local17, local12)
            local17 = vector.Scale(local17, 0.01)
            local18 = vector.Set(0.0, local13 * local15 * local14 * local10.TURTLE_RAM_UPWARD_IMPACT_SCALE * arg2, 0.0, 0.0)
            physics.ApplyImpulse(local5, local18, local7)
            local18 = vector.Scale(local18, 0.01)
        local19 = arg1.turtle_ram_side * local15 * local14 * local10.TURTLE_RAM_PLAYER_IMPACT_SCALE * arg3 * arg2
        local20 = vector.Scale(local9.r0, local19)
        physics.ApplyImpulse(local8, local20, arg4)
        local20 = vector.Scale(local20, 0.01)

def UpdateCruiseMode(self, arg1, arg2):
    local3 = self.Wheels
    local4 = arg1.prev_cruiseroughness
    local5 = self.Drivetrain.CruiseRoughness
    local6 = self.Drivetrain.SmoothedCruiseRoughness
    if local6 == 0.0:
        ExitCruiseMode(self, arg1)
        return
    arg1.prev_cruiseroughness = local6
    if 0.0 >= local4:
        if local6 > 0.0:
            vehicle.SendVehicleSoundEvent(self.VehicleGameObject, @CEA42402)
    local7 = arg1.cruisePhase
    local8 = -vehicle.GetLocalVelocity(self.VehicleGameObject).z
    if local6 > 0.0:
        arg1.cruise_speed_duration = arg1.cruise_speed_duration + arg2
        arg1.cruise_speed_best_speed = math.Max(arg1.cruise_speed_best_speed, local8)
        local9 = local8 * arg2
        arg1.cruise_speed_distance = arg1.cruise_speed_distance + local9
    local10 = self.Mass * vector.Length(physics.GetGravity())
    local11 = self.RearAxleToCoMDistance / (self.FrontAxleToCoMDistance + self.RearAxleToCoMDistance)
    local12 = math.Clamp(local8 / 42.5 * 10.0, 5.0, 10.0)
    local13 = math.Clamp(local8 / 42.5 * 15.0, 10.0, 15.0)
    local14 = self.Inertia.x / self.Mass * 11.0
    local15 = local14 / 15.0 * local13
    local15 = local15 * math.Lerp(local6, 0.0, 0.0)
    local16 = 2.0 * math.Pi()
    local18 = 0.0
    local19 = 1.0
    local17 = 4.0
    while local17 > local18:
        local20 = vector.Add(local7[local18], vector.Set(0.0, local16 * math.Lerp(math.Rand(), local12, local13) * arg2, local16 * math.Lerp(math.Rand(), local12, local13) * arg2, 0.0))
        vector.Set(0.0, fmod(local20.y, local16), fmod(local20.z, local16), 0.0)[local7] = local18
        local18 = local19 + local18
    local18 = 0.0
    local22 = 1.0
    local21 = 4.0
    while local21 > local18:
        local23 = local3[local18]
        if local23.Axle == 0.0:
            local24 = 0.5 * local10 * local11
        elif local23.Axle == 1.0:
            local24 = 0.5 * local10 * (1.0 - local11)
        local25 = math.Clamp(local23.Load, 0.0, local24)
        local3[local18].ExtraChassisForce = vector.Scale(vector.Set(0.0, math.Sin(local7[local18].y), math.Sin(local7[local18].z), 0.0), local15 * local25)
        local18 = local22 + local18
    arg1.cruisePhase = local7

def UpdateTopspeedDialogue(self, arg1, arg2):
    local3 = arg1.VehicleGameObject
    local4 = vehicle.GetFilteredNormalizedRPM(local3)
    local5 = arg1.Drivetrain.Gear
    local6 = arg1.AeroSpeedCap * 0.95
    local7 = arg1.Drivetrain.NbGears - 2.0
    local8 = math.Abs(vehicle.GetLocalVelocity(local3).z)
    if local4 > 0.9 and local5 >= local7 and local8 >= local6:
        scriptgo.SendEvent(self, @AE15497C)

def UpdateComboDetection(self, arg1, arg2):
    local3 = arg1.VehicleGameObject
    local4 = character.GetVehicle(character.GetPlayer())
    if local4 != none:
        local5 = game.GetTransform(local3)
        local6 = game.GetTransform(local4)
        local7 = vehicle.GetWheelContactRatio(local3)
        local8 = vector.Distance(local5.r3, local6.r3)
        local9 = vehicle.GetVelocity(local4)
        local10 = vector.Length(local9)
        local9 = vector.Normalize(local9)
        local11 = vehicle.GetVelocity(local3)
        local12 = vector.Length(local11)
        local11 = vector.Normalize(local11)
        if local10 > 2.0 and local12 > 2.0:
            local13 = vector.Dot(local11, local9)
            local14 = vector.Sub(local5.r3, local6.r3)
            local15 = vector.Normalize(local14)
            local16 = vector.Dot(local5.r2, local15)
            if -0.95 > local13 and local16 > 0.95 and 20.0 > local8:
                vehiclemanager.StartComboTarget(@24AC0B91, local3)

def UpdateRollOverDamage(self):
    if 0.5 >= vehicle.GetWheelContactRatio(self) and -0.5 > game.GetTransform(self).r1.y:
        scriptgo.Call2(lib_entity_proxy.GetBodyHealth(self), @2925E205, 1E+08, lib_damage_types.DAMAGE_ROLLOVER())

def InitDeform(self):
    local1 = scriptgo.GetProperties(self)
    local1.old_deform = 0.0

def UpdatePlayerGameplay(self, arg1, arg2):
    local3 = scriptgo.GetProperties(self)
    UpdateFallTracking(arg1, arg2)
    UpdateCruiseMode(arg1, local3, arg2)
    UpdateTurtleRam(arg1, local3, arg2)
    UpdateBoost(arg1, arg2)
    UpdatePlayerDialogue(self, arg1, arg2)
    UpdateDeformationGameplay(self, arg1, arg2)

def UpdateAIBoost(self, arg1):
    local2 = self.VehicleGameObject
    local3 = self.Drivetrain
    if local3.AIBoostAcceleration != 0.0:
        if self.Throttle > 0.0 and vehicle.GetWheelContactRatio(local2) == 1.0:
            physics.ApplyImpulse(local2, vector.Scale(game.GetTransform(local2).r2, -local3.AIBoostAcceleration * vehicle.GetMass(local2) * arg1), vehicle.GetCenterOfMass(local2))

def UpdateDeformationGameplay(self, arg1, arg2):
    local3 = arg1.VehicleGameObject
    local4 = scriptgo.GetProperties(self)
    local5 = vehicle.GetDeformValueFront(local3)
    if local5 >= 1.0 and 1.0 >= local4.old_deform:
        scriptgo.PostEvent(self, @34A19D5A)
    elif 1.0 > local5 and local4.old_deform >= 1.0:
        scriptgo.PostEvent(self, @8A930538)
    local4.old_deform = local5
