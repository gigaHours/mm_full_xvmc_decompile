module lib_character
import @87A2ECFD

def GetFilteredLSAccelerationOnVehicle(self, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8):
    local9 = vector.Set(0.0, 0.0, 0.0, 0.0)
    local10 = local9
    if none == self.vel_last:
        self.vel_last = local9
        self.vel_curr = local9
        self.acc_filtered = local9
        self.acc_filtered_last = local9
        self.acc_int_last = local9
        self.acc_int_curr = local9
        self.acc_over_last = local9
        self.acc_over_curr = local9
    local11 = character.GetVehicle(arg2)
    if none != local11:
        local12 = character.GetWorldMatrix(arg2)
        local13 = local12.r3
        self.vel_last = vector.Clone(self.vel_curr)
        self.vel_curr = physics.GetPointVelocity(local11, local13)
        local10 = vector.Sub(self.vel_curr, self.vel_last)
        local10 = vector.Scale(local10, 1.0 / arg1)
        local10 = AccToCharSpace(local10, arg2)
        local10 = AccDeadzone(local10, arg3)
        self.acc_int_last = vector.Clone(self.acc_int_curr)
        self.acc_int_curr = vector.Lerp(arg5 * arg1, self.acc_int_last, local10)
        local10 = self.acc_int_curr
        local10 = AccApplyLimits(local10, arg4)
        if not arg7:
            local10 = AccGravity(local10, arg2, arg8)
            local10 = AccAirResistance(local10, arg2, self.vel_curr)
            local10 = AccApplyOverflow(local10, self.acc_over_curr, arg6)
            local14 = AccGetOverflow(local10)
            self.acc_over_last = vector.Clone(self.acc_over_curr)
            self.acc_over_curr = vector.Lerp(arg5 * arg1, self.acc_over_last, local14)
        local10 = AccClamp(local10)
    return local10

def CastRays(self, arg1, arg2, arg3):
    raycast.ClearRays(self)
    local4 = len(arg1)
    local5 = list.MakeList(local4, none)
    local7 = 0.0
    local8 = 1.0
    local6 = local4
    while local6 > local7:
        local9 = arg1[local7]
        local10 = local9[0.0]
        local11 = local9[1.0]
        local5[local7] = raycast.AddRay(self, local10, local11)
        local7 = local8 + local7
    local12 = none
    raycast.CastRays(self)
    local7 = 0.0
    local14 = 1.0
    local13 = local4
    while local13 > local7:
        local15 = lib_color.WHITE(1.0)
        local16 = local5[local7]
        local17 = local16.To
        if local16.Hits:
            local18 = none
            if arg2:
                local18 = arg2(local16.Hits[0.0])
            else:
                local18 = local16.Hits[0.0]
            if local18:
                local15 = lib_color.RED(1.0)
                local17 = local18.Position
                local12 = local18
        if arg3:
            debug.Arrow(local16.From, local17, 0.03, local15)
        if local12:
            return local12
        local7 = local14 + local7

def IsCoughing(self):
    return character.IsContextBitSet(self, 27.0)

def RotateDirWS2LS(self, arg1):
    local2 = matrix.CopyMatrix(self)
    local2.r3 = vector.Set(0.0, 0.0, 0.0, 1.0)
    local2 = matrix.Inverse(local2)
    return matrix.MulVec(local2, arg1)

def CalcCharacterRot(self, arg1, arg2, arg3):
    local4 = character.GetWorldMatrix(self)
    local5 = vector.Set(-local4.r2.x, -local4.r2.z, 0.0, 0.0)
    local6 = vector.Set(arg2.x, arg2.z, 0.0, 0.0)
    local7 = vector.SpeedSlerp2(arg1, local5, local6, arg3)
    return vector.Set(local7.x, 0.0, local7.y, 0.0)

def GetFlattenedCameraDir(self):
    local1 = camera.GetCameraTransform()
    local2 = vector.Scale(local1.r2, -1.0)
    return vector.Normalize(vector.Sub(local2, vector.Scale(self, vector.Dot(local2, self))))

def DrawCharacterDebug(self):
    local1 = character.GetWorldMatrix(self)
    lib_debugdraw.DrawDebugMatrix(local1)

def AccApplyLimits(self, arg1):
    return vector.Set(self.x / arg1.x, self.y / arg1.y, self.z / arg1.z, 0.0)

def CopyNormalizedTime(self, arg1):
    local2 = self.Time / self.Length
    arg1.Time = local2 * arg1.Length

def RotateDirLS2WS(self, arg1):
    local2 = matrix.CopyMatrix(self)
    local2.r3 = vector.Set(0.0, 0.0, 0.0, 1.0)
    return matrix.MulVec(local2, arg1)

def AccApplyOverflow(self, arg1, arg2):
    if vector.Length(arg1) > 0.0:
        return vector.Add(self, vector.Scale(arg1, arg2))
    return self

def GetRunAmount(self, arg1, arg2):
    local3 = 1.0
    local4 = GetFilteredMoveInputMagnitude()
    if local4 > 0.0:
        if arg1 == arg2:
            local3 = arg2
        else:
            local3 = math.Scale01(local4, arg1, arg2)
    else:
        local3 = 0.0
    return local3

def GetRawMoveInputLocalDir():
    local0 = input.GetRawMoveInput()
    local1 = input.TransformInputDirToLocalDir(local0)
    if vector.Length(local1) > 0.0:
        local1 = vector.Normalize(local1)
    return local1

def GetStickLimits():
    local0 = 0.15
    local1 = 0.5
    local2 = 0.85
    return vector.Set(local0, local1, local2, 0.0)

def GetNormalizedSigmoidBasedOnClamp(self, arg1, arg2):
    local3 = math.Clamp((self - arg1) / arg2, 0.0, 1.0)
    return GetNormalizedSigmoid(local3)

def AccScaleExp(self):
    local1 = vector.Length(self)
    local2 = self
    if local1 > 0.0:
        local3 = vector.Normalize(self)
        local1 = local1 * local1
        local2 = vector.Scale(local3, local1)
    return local2

def AccDeadzone(self, arg1):
    local2 = vector.Length(self)
    local3 = self
    if local2 > 0.0:
        local2 = math.Max(local2 - arg1, 0.0)
        local4 = vector.Normalize(self)
        local3 = vector.Scale(local4, local2)
    return local3

def AccGravity(self, arg1, arg2):
    local3 = 0.03
    local4 = character.GetWorldMatrix(arg1)
    local5 = vector.Set(0.0, -1.0, 0.0, 0.0)
    if arg2:
        local6 = vector.Set(-0.5, -0.5, -0.5, 0.0)
    else:
        local6 = vector.Set(-2.0, -0.2, -2.0, 0.0)
    local7 = math.Clamp(vector.Dot(local4.r0, local5) * local6.x, -1.0, 1.0)
    local8 = math.Clamp(vector.Dot(local4.r1, local5) * local6.y, -1.0, 1.0)
    local9 = math.Clamp(vector.Dot(local4.r2, local5) * local6.z, -1.0, 1.0)
    return vector.Set(self.x + local7, self.y + local8, self.z + local9, 0.0)

def GetBreath(self):
    local1 = character.GetFloatRegister(self, 8.0)
    return local1

def GetTranslationFromRotatingAroundPivotInY(self, arg1, arg2):
    local3 = matrix.CopyMatrix(self)
    local4 = vector.Scale(vector.Sub(self.r3, arg1.r3), -1.0)
    local5 = math.Sin(arg2)
    local6 = math.Cos(arg2)
    local7 = local4.x * local6 - local4.z * local5 - local4.x
    local8 = local4.x * local5 + local4.z * local6 - local4.z
    local9 = vector.Set(local7, 0.0, local8, 0.0)
    local3.r3 = vector.Add(self.r3, local9)
    return local3

def GetFilteredMoveInputLocalDir():
    local0 = input.GetFilteredMoveInput()
    local1 = input.TransformInputDirToLocalDir(local0)
    if vector.Length(local1) > 0.0:
        local1 = vector.Normalize(local1)
    return local1

def GetSegmentLength(self):
    local1 = self.End - self.Start
    return local1

def AccGetOverflowComponent(self):
    local1 = math.Sign(self)
    return math.Clamp(local1 * math.Max(self / local1 - 1.0, 0.0), -1.0, 1.0)

def CharacterFilterHit(self):
    local1 = self.GameObject
    if not local1:
        return self
    if not character.IsCharacter(local1):
        return self
    return none

def CheckBufferedMovementDirection(self, arg1):
    local2 = character.GetPlayer()
    local3 = game.GetTransform(local2).r3
    local4 = game.GetBlackboardValueFromObject(local2, @8E52D244)
    local5 = game.GetBlackboardValueFromObject(local2, @43212CE7)
    local6 = 5.0
    local7 = 10.0
    local8 = 0.035
    if local4 and local5:
        local9 = math.RadToDeg(vector.AngleBetween(local5, arg1))
        if local6 > local9:
            debug.Arrow(local3, vector.Add(local3, vector.Scale(local4, 2.0)), 0.1, lib_color.ORANGE(1.0))
            game.SetBlackboardValueToObject(local2, @C8FE63F7, 0.0)
            return local4
        debug.DrawText(vector.Set(0.1, 0.5, 0.0, 0.0), "ang_dif_ws: %f", [local9], lib_color.GREEN(1.0))
        local10 = game.GetBlackboardValueFromObject(local2, @C8FE63F7)
        if not local10:
            local10 = 0.0
        local10 = math.Lerp(local8, local10, 1.0)
        game.SetBlackboardValueToObject(local2, @C8FE63F7, local10)
        local11 = vector.Lerp(local10, local4, self)
        local12 = math.RadToDeg(vector.AngleBetween(local11, self))
        debug.LogInfo("Inside interpolation, bb_stick_blend: %f, ang_dif_ws: %f", [local10, local12])
        if local12 > local7:
            debug.Arrow(local3, vector.Add(local3, vector.Scale(local11, 2.0)), 0.1, lib_color.GREEN(1.0))
            return local11
        ResetBufferedMovementDirection()
        debug.DrawText(vector.Set(0.1, 0.5, 0.0, 0.0), "ang: %f", [local9], lib_color.YELLOW(1.0))

def AccGetClampedComponent(self):
    local1 = math.Sign(self)
    return local1 * math.Min(math.Abs(self), 1.0)

def GetEmptySwayingAnimationBlend(self):
    return [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

def GetRawMoveInputWorldDir():
    local0 = input.GetRawMoveInput()
    local1 = camera.TransformInputDirToWorldDir(local0)
    if vector.Length(local1) > 0.0:
        local1 = vector.Normalize(local1)
    return local1

def GetFilteredMoveInputWorldDir():
    local0 = input.GetFilteredMoveInput()
    local1 = camera.TransformInputDirToWorldDir(local0)
    if vector.Length(local1) > 0.0:
        local1 = vector.Normalize(local1)
        local2 = none
        if local2:
            local1 = local2
    else:
        ResetBufferedMovementDirection()
    return local1

def DrawCharacter(self):
    local1 = character.GetWorldMatrix(self)
    lib_debugdraw.DrawDebugMatrix(local1)

def CheckIfSlidey(self, arg1):
    local2 = character.GetGroundInfo(self)
    local3 = local2.Normal
    local4 = vector.Set(0.0, 1.0, 0.0, 0.0)
    local5 = true
    local6 = vector.Dot(local4, local3)
    if 0.695 > local6:
        local7 = vector.Add(arg1.r3, vector.Set(0.0, 0.1, 0.0, 0.0))
        local8 = local3
        local9 = game.GetChild(self, "raycaster")
        local10 = GetFootRayCastedNormal(self, local9, arg1, "RightFoot")
        local11 = GetFootRayCastedNormal(self, local9, arg1, "LeftFoot")
        if local10 and local11:
            local12 = vector.Add(local10.Normal, local11.Normal)
            if vector.Dot(local4, vector.Normalize(local12)) > 0.695:
                local5 = false
            local8 = vector.Add(vector.Scale(local3, 2.0), local12)
            if vector.Dot(local4, local10.Normal) > 0.695:
                local5 = false
            if vector.Dot(local4, local11.Normal) > 0.695:
                local5 = false
        elif local10:
            if vector.Dot(local4, local10.Normal) > 0.695:
                local5 = false
            local8 = vector.Add(local3, local10.Normal)
        elif local11:
            if vector.Dot(local4, local11.Normal) > 0.695:
                local5 = false
            local8 = vector.Add(local3, local11.Normal)
        local8 = vector.Normalize(local8)
        game.SetBlackboardValueToObject(self, @91219935, local8)
        local13 = 0.4
        local14 = vector.Scale(arg1.r2, -local13)
        local15 = vector.Add(arg1.r3, local14)
        local15.y = local15.y + local13
        local16 = vector.Add(arg1.r3, local14)
        local16.y = local16.y - local13
        local17 = lib_character.CastRays(local9, [[local15, local16]], CharacterFilterHit, false)
        if local17:
            local18 = vector.Dot(local4, local17.Normal)
            if local18 > 0.695:
                local5 = false
        local19 = vector.Clone(local8)
        local19.y = 0.0
        local19 = vector.Normalize(local19)
        local19 = vector.Scale(local19, 0.3)
        local20 = vector.Add(arg1.r3, local14)
        local21 = vector.Clone(local20)
        local21.y = local21.y - 0.5
        local22 = lib_character.CastRays(local9, [[local20, local21]], CharacterFilterHit, false)
        if local22:
            local23 = vector.Dot(local4, local22.Normal)
            if local23 > 0.695:
                local5 = false
        local24 = vector.Dot(local4, local8)
        if local5:
            if 0.695 > local24:
                local25 = vector.Add(arg1.r3, vector.Set(0.0, 0.25, 0.0, 0.0))
                local26 = vector.Clone(local8)
                local26.y = 0.0
                local26 = vector.Normalize(local26)
                local27 = vector.Add(local25, local26)
                local28 = lib_character.CastRays(local9, [[local25, local27]], CharacterFilterHit, false)
                local29 = vector.Set(0.1, 0.25, 0.0, 0.0)
                if local28:
                    return false
                return true
    return false

def ResetBufferedMovementDirection():
    local0 = character.GetPlayer()
    local1 = game.GetBlackboardValueFromObject(local0, @8E52D244)
    if local1:
        game.ClearBlackboardValueFromObject(local0, @8E52D244)
        game.ClearBlackboardValueFromObject(local0, @43212CE7)
        game.SetBlackboardValueToObject(local0, @C8FE63F7, 0.0)

def AccGetOverflow(self):
    local1 = AccGetOverflowComponent(self.x)
    local2 = AccGetOverflowComponent(self.y)
    local3 = AccGetOverflowComponent(self.z)
    return vector.Set(local1, local2, local3, 0.0)

def GetFilteredMoveInputSpeed():
    local0 = input.GetFilteredMoveInputVelocity()
    local1 = vector.Length(local0)
    return local1

def CalcSwayingAnimationBlend(self, arg1):
    local2 = scriptgo.GetProperties(self)
    local3 = 0.0
    local4 = 0.0
    local5 = 0.0
    local6 = 0.0
    local7 = 0.0
    local8 = 0.0
    local9 = 0.0
    local10 = math.Abs(arg1.x)
    local11 = math.Abs(arg1.z)
    local12 = math.Abs(arg1.y)
    if 0.0 > arg1.x:
        local4 = 0.0
        local5 = local10
    else:
        local4 = local10
        local5 = 0.0
    if arg1.z > 0.0:
        local6 = local11
        local7 = 0.0
    else:
        local6 = 0.0
        local7 = local11
    if arg1.y > 0.0:
        local8 = local12
        local9 = 0.0
    else:
        local8 = 0.0
        local9 = local12
    local3 = math.Clamp(1.0 - local4 - local5 - local6 - local7 - local8 - local9, 0.0, 1.0)
    return [local3, local4, local5, local6, local7, local8, local9]

def ZeroBreath(self):
    character.SetFloatRegister(self, 8.0, 0.0)

def GetRawMoveInputSpeed():
    local0 = input.GetRawMoveInputVelocity()
    local1 = vector.Length(local0)
    return local1

def GetFootRayCastedNormal(self, arg1, arg2, arg3):
    local4 = animation.GetPoseTransformById(self, arg3)
    local5 = matrix.Mul(local4, arg2).r3
    local6 = vector.Add(local5, vector.Set(0.0, 0.7, 0.0, 0.0))
    local7 = vector.Add(local5, vector.Set(0.0, -0.7, 0.0, 0.0))
    return lib_character.CastRays(arg1, [[local6, local7]], CharacterFilterHit, false)

def ZeroSamplers(self, arg1):
    local2 = arg1
    local3 = animation.GetSamplerCount(self)
    while local3 > local2:
        animation.GetSampler(self, local2).Weight = 0.0
        local2 = local2 + 1.0

def RotateTowards2D(self, arg1, arg2, arg3):
    local4 = vector.Set(arg1.x, arg1.z, 0.0, 0.0)
    local5 = vector.Set(arg2.x, arg2.z, 0.0, 0.0)
    local6 = vector.SpeedSlerp2(self, local4, local5, arg3)
    return vector.Set(local6.x, 0.0, local6.y, 0.0)

def GetRawMoveInputMagnitude():
    local0 = input.GetRawMoveInput()
    local1 = vector.Length(local0)
    return local1

def DrawFootsteps(self):
    local1 = character.GetWorldMatrix(self)
    local2 = animation.IsWithinSegment(self, @E063F6A0, @36081070)
    local3 = animation.IsWithinSegment(self, @E063F6A0, @D30B678D)
    local4 = vector.Add(local1.r3, vector.Scale(local1.r0, -0.25))
    local5 = vector.Add(local1.r3, vector.Scale(local1.r0, 0.25))
    local6 = vector.Set(1.0, 1.0, 1.0, 0.6)
    local7 = vector.Set(0.7, 0.1, 0.2, 0.6)
    local8 = 0.2
    local9 = 0.4
    if local2:
        debug.Sphere(local4, local8, local6)
    if local3:
        debug.Sphere(local5, local8, local7)
    "\n    if seg_left_foot_long:\n        debug.Sphere(left_foot, debug_radius_long, col_left)   \n    if seg_right_foot_long:\n        debug.Sphere(right_foot, debug_radius_long, col_right)\n    "

def AccToCharSpace(self, arg1):
    local2 = 0.03
    local3 = character.GetWorldMatrix(arg1)
    local4 = matrix.Inverse(local3)
    local4.r3 = vector.Set(0.0, 0.0, 0.0, 1.0)
    return matrix.MulVec(local4, self)

def CalculateSlope(self, arg1, arg2, arg3, arg4, arg5, arg6):
    local7 = character.GetWorldMatrix(self)
    local8 = math.Cos(arg4)
    local9 = vector.Dot(arg6.Normal, local7.r2)
    local9 = math.Clamp(local9, -local8, local8)
    local9 = math.Scale(local9, -local8, local8, -1.0, 1.0)
    if local9 > arg5 and arg5 > 0.0:
        return math.SpeedLerp(arg5, local9, arg2, arg3)
    return math.SpeedLerp(arg5, local9, arg1, arg3)

def AddBreath(self, arg1):
    local2 = character.GetFloatRegister(self, 8.0)
    local2 = local2 + arg1
    local2 = math.Clamp(local2, 0.0, 180.0)
    character.SetFloatRegister(self, 8.0, local2)
    return local2

def CalculateBanking(self, arg1, arg2, arg3, arg4):
    local5 = character.GetWorldMatrix(self)
    local6 = local5.r0
    local7 = 0.0
    if vector.Length(arg3) > 0.0 and vector.Length(local6) > 0.0:
        local7 = vector.Dot(arg3, local6)
    local8 = 3.4
    local7 = math.Clamp(local7 * local8, -1.0, 1.0)
    if 0.05 > math.Abs(local7):
        arg4 = math.SpeedLerp(arg4, local7, arg1.y, arg2)
    else:
        local9 = 0.0 + arg4
        local10 = character.GetMeasuredAngularVelocity(self).y
        local11 = math.Sign(local10) * -1.0
        local12 = (math.Clamp(math.Abs(local10), 0.2, 10.2) - 0.2) * 0.1 * local11
        if math.Sign(arg4) == math.Sign(local7) and math.Abs(arg4) > math.Abs(local7):
            arg4 = math.SpeedLerp(arg4, local7, arg1.y, arg2)
        else:
            arg4 = math.SpeedLerp(arg4, local7, arg1.x, arg2)
        local13 = 0.0 + arg4
        if math.Sign(arg4) == math.Sign(local12) and math.Abs(arg4) > math.Abs(local12):
            arg4 = math.SpeedLerp(arg4, local12, arg1.w, arg2)
        else:
            arg4 = math.SpeedLerp(arg4, local12, arg1.z, arg2)
        arg4 = math.Lerp(0.65, local9, arg4)
    local14 = 0.06
    local15 = math.Sign(arg4)
    arg4 = local15 * (math.Clamp(math.Abs(arg4), local14, 1.0) - local14) / (1.0 - local14)
    return arg4

def GetNormalizedSigmoid(self):
    local1 = [0.0, 0.0, 1.0, 1.0]
    local2 = self * self * self * (-local1[0.0] + 3.0 * local1[1.0] - 3.0 * local1[2.0] + local1[3.0]) + self * self * (3.0 * local1[0.0] - 6.0 * local1[1.0] + 3.0 * local1[2.0]) + self * (-3.0 * local1[0.0] + 3.0 * local1[1.0]) + local1[0.0]
    return local2

def ScalePump(self):
    local1 = math.Abs(self)
    local2 = 1.0 - local1
    local1 = 1.0 - local2 * local2 * local2 * local2
    self = local1 * math.Sign(self)
    return self

def AccClamp(self):
    local1 = AccGetClampedComponent(self.x)
    local2 = AccGetClampedComponent(self.y)
    local3 = AccGetClampedComponent(self.z)
    local4 = vector.Set(local1, local2, local3, 0.0)
    return local4

def GetTranslationFromRotatingCharacterAroundJointNameInY(self, arg1, arg2):
    local3 = character.GetWorldMatrix(self)
    local4 = animation.GetPoseTransformById(self, arg1)
    local5 = matrix.Mul(local4, local3)
    local6 = GetTranslationFromRotatingAroundPivotInY(local3, local5, arg2)
    return local6

def AccAirResistance(self, arg1, arg2):
    local3 = 0.03
    local4 = character.GetWorldMatrix(arg1)
    local5 = arg2
    local6 = 0.025
    local7 = vector.Set(local6, local6, local6, 0.0)
    local8 = math.Clamp(vector.Dot(local4.r0, local5) * local7.x, -1.0, 1.0)
    local9 = math.Clamp(vector.Dot(local4.r1, local5) * local7.y, -1.0, 1.0)
    local10 = math.Clamp(vector.Dot(local4.r2, local5) * local7.z, -1.0, 1.0)
    return vector.Set(self.x + local8, self.y + local9, self.z + local10, 0.0)

def GetFilteredMoveInputMagnitude():
    local0 = input.GetFilteredMoveInput()
    local1 = vector.Length(local0)
    return local1

def SegmentNonExistentOrWithin(self, arg1, arg2):
    if not arg2:
        return true
    local3 = animation.GetSegmentInfo(self, arg1, arg2)
    if not local3:
        return true
    if local3 and animation.IsWithinSegment(self, arg1, arg2):
        return true
    return false

def SetWeightAndSynchronizeAnimationTimeAndSpeedBasedOnWeightArray(self, arg1, arg2, arg3):
    local4 = animation.GetSampler(arg2, 0.0).Time / animation.GetSampler(arg2, 0.0).Length
    local5 = 0.0
    local6 = 0.0
    local8 = 0.0
    local9 = 1.0
    local7 = len(arg1)
    while local7 > local8:
        local6 = local6 + arg1[local8] * animation.GetSampler(arg2, local8).Length
        local5 = local5 + arg1[local8]
        local8 = local9 + local8
    local6 = local6 / local5
    if local5 > 0.0:
        local8 = 0.0
        local11 = 1.0
        local10 = len(arg1)
        while local10 > local8:
            animation.GetSampler(arg2, local8).Weight = arg1[local8]
            animation.GetSampler(arg2, local8).Speed = animation.GetSampler(arg2, local8).Length / local6 * arg3
            animation.GetSampler(arg2, local8).Time = animation.GetSampler(arg2, local8).Length * local4
            local8 = local11 + local8
