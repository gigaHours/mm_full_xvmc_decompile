module weapon_aiming
import @78DDD3EE
import @58351C01

def TransitionFrom(self, arg1):
    self.Properties.car_transparency_enabled = false

def MIN_ELEVATION_DEFVAL():
    return -17.0

def DistanceRel(self, arg1, arg2, arg3):
    return math.Max(math.Min((self - arg1) / (arg2 - arg1), 1.0), 0.0)

def EnterAlignedTransition(self, arg1, arg2):
    local3 = math.DegToRad(PropertyWithDefault(self.Properties.min_elevation, MIN_ELEVATION_DEFVAL()))
    local4 = math.DegToRad(PropertyWithDefault(self.Properties.max_elevation, MAX_ELEVATION_DEFVAL()))
    local5 = math.DegToRad(PropertyWithDefault(self.Properties.distance_push_start, DISTANCE_PUSH_START_DEFVAL()))
    local6 = PropertyWithDefault(self.Properties.distance_push_length, DISTANCE_PUSH_LENGTH_DEFVAL())
    local7 = PropertyWithDefault(self.Properties.distance_fov_start, DISTANCE_FOV_START_DEFVAL())
    local8 = PropertyWithDefault(self.Properties.distance_fov_end, DISTANCE_FOV_END_DEFVAL())
    local9 = 0.0 == self.Properties.weapon
    local10 = 1.0 == self.Properties.weapon
    local11 = 2.0 == self.Properties.weapon
    lib_camera.AlignAzimuthToSourceCamera(self, arg1, arg2)
    lib_camera.AlignElevationToSourceCameraClamped(self, arg1, arg2, local3, local4)
    local12 = GetWeaponGO(self)
    self.Properties.target_info = scriptgo.Call(local12, @F15876CB)
    UpdateAutoTarget(self)
    self.Properties.offset_azimuth = 0.0
    self.Properties.offset_elevation = 0.0
    DoAutoAim(self, arg2, 0.5, local11)
    self.Properties.speed_scale_current = 1.0
    self.Properties.CurrentOffsetYaw = 0.0
    self.Properties.CurrentOffsetPitch = 0.0
    self.Properties.zoom_fov_current = none
    self.Properties.zoom_vel_current = none
    self.Properties.AccelerationProgress = 0.4
    self.Properties.car_transparency_enabled = true
    self.Properties.trans_weight_prev = self.TranslationWeight
    if local10 and 1.0 == self.Properties.mode:
        self.Properties.do_initial_alignment = true
    else:
        self.Properties.do_initial_alignment = false
    lib_camera.ResetDamping(self)
    arg2.CameraTransform = camera.CalculateCameraTransform(self)

def MAX_ELEVATION_DEFVAL():
    return 40.0

def DistanceFOV(self, arg1, arg2, arg3, arg4, arg5):
    local6 = DistanceRel(self, arg1, arg2, arg3)
    return arg4 + local6 * local6 * (arg5 - arg4)

def DISTANCE_PUSH_LENGTH_DEFVAL():
    return 3.5

def DISTANCE_PUSH_START_DEFVAL():
    return -2.0

def DISTANCE_FOV_END_DEFVAL():
    return 56.0

def UpdateAutoTarget(self):
    local1 = GetWeaponGO(self)
    self.Properties.target = none
    if local1 != none:
        local2 = self.Properties.target_info
        self.Properties.target = game.StateContainerDataWeaponGetAlignTarget(local2)
        self.Properties.offset_azimuth = game.StateContainerDataWeaponGetAlignTargetOffsetAzimuth(local2)
        self.Properties.offset_elevation = game.StateContainerDataWeaponGetAlignTargetOffsetElevation(local2)
        if self.Properties.offset_azimuth != none:
            self.Properties.offset_azimuth = self.Properties.offset_azimuth
        else:
            self.Properties.offset_azimuth = 0.0
        if self.Properties.offset_elevation != none:
            self.Properties.offset_elevation = self.Properties.offset_elevation
        else:
            self.Properties.offset_elevation = 0.0

def Init(self):
    lib_camera.ResetDamping(self)
    self.Properties.trans_weight_prev = self.TranslationWeight
    self.Properties.speed_scale_current = 1.0
    self.Properties.zoom_fov_current = none
    self.Properties.zoom_vel_current = none

def GetRealDt(self):
    local1 = self.Dt
    local2 = game.GetUpdateSpeed()
    if local2 > 0.0:
        local1 = self.Dt / local2
    return local1

def PropertyWithDefault(self, arg1):
    if self == none:
        return arg1
    return self

def ExitTransition(self, arg1):
    pass

def EnterUnalignedTransition(self, arg1):
    debug.LogWarning("Weapon Aim Camera", "EnterUnalignedTransition is not supported in this modifier.")

def DoAutoAim(self, arg1, arg2, arg3):
    local4 = self.Properties.target
    if local4 != none:
        local5 = game.TargetObjectGetTargetPos(local4)
        if local5 != none:
            if false:
                debug.StarNoZ(local5, 0.1, lib_color.RED(0.6))
            if arg3:
                camera.InterpolateCameraOffset(self, local5, arg2)
                return true
            local6 = lib_camera.GetAzElTowardsPos(self, arg1, local5, arg2)
            if local6:
                if false:
                    if self.Properties.offset_azimuth != none and self.Properties.offset_elevation != none:
                        debug.DrawText(vector.Set(0.05, 0.4, 0.0, 0.0), "offsets: a:%f e:%f ", [self.Properties.offset_azimuth, self.Properties.offset_elevation], lib_color.ORANGE(1.0))
                    else:
                        debug.DrawText(vector.Set(0.05, 0.4, 0.0, 0.0), "offsets: None", [], lib_color.ORANGE(1.0))
                camera.SetOffsetDeltaOrbit(self, local6[0.0] - self.Properties.offset_azimuth - self.OffsetAzimuth, local6[1.0] - self.Properties.offset_elevation - self.OffsetElevation)
                return true
    return false

def GetAutoAimInterpolationScale(self):
    local1 = 0.65
    if self.Properties.auto_aim_interpolation_use_time:
        local2 = game.StateContainerDataWeaponGetActiveAlignTargetTime(self.Properties.target_info)
        local3 = math.Clamp01(local2 / self.Properties.auto_aim_interpolation_time)
        local1 = local3
    return local1

def GetWeaponGO(self):
    local1 = none
    if 0.0 == self.Properties.weapon:
        local1 = lib_entity_proxy.GetHarpoon(vehicle.GetSignatureVehicle())
    elif 1.0 == self.Properties.weapon:
        local1 = lib_entity_proxy.GetShotgun(character.GetPlayer())
    elif 2.0 == self.Properties.weapon:
        local1 = lib_entity_proxy.GetSniper(vehicle.GetSignatureVehicle())
    return local1

def DistancePush(self, arg1, arg2, arg3):
    local4 = DistanceRel(self, arg1, arg2, arg3)
    return local4 * local4 * arg3

def DISTANCE_FOV_START_DEFVAL():
    return 40.0

def UpdateDebug(self, arg1):
    camera.SetOffsetDeltaOrbit(self, 0.0, 0.0)
    local2 = camera.CalculateCameraTransform(self)
    arg1.CameraTransform = local2
    debug.DrawText(vector.Set(0.05, 0.25, 0.0, 0.0), "az: %f, el: %f, dist: %f", [self.OffsetAzimuth, self.OffsetElevation, self.OffsetDistance], lib_color.WHITE(1.0))

def Update(self, arg1):
    local2 = 0.0
    local3 = 0.0
    local4 = math.DegToRad(PropertyWithDefault(self.Properties.min_elevation, MIN_ELEVATION_DEFVAL()))
    local5 = math.DegToRad(PropertyWithDefault(self.Properties.max_elevation, MAX_ELEVATION_DEFVAL()))
    local6 = math.DegToRad(PropertyWithDefault(self.Properties.distance_push_start, DISTANCE_PUSH_START_DEFVAL()))
    local7 = PropertyWithDefault(self.Properties.distance_push_length, DISTANCE_PUSH_LENGTH_DEFVAL())
    local8 = PropertyWithDefault(self.Properties.distance_fov_start, DISTANCE_FOV_START_DEFVAL())
    local9 = PropertyWithDefault(self.Properties.distance_fov_end, DISTANCE_FOV_END_DEFVAL())
    local10 = PropertyWithDefault(self.Properties.speed_modifier, 1.0)
    local11 = 0.0 == self.Properties.weapon
    local12 = 1.0 == self.Properties.weapon
    local13 = 2.0 == self.Properties.weapon
    local14 = GetRealDt(self)
    local15 = false
    UpdateAutoTarget(self)
    local16 = self.TranslationWeight - self.Properties.trans_weight_prev
    self.Properties.trans_weight_prev = self.TranslationWeight
    if local16 > 0.0 or 1.0 == self.TranslationWeight:
        local15 = DoAutoAim(self, arg1, GetAutoAimInterpolationScale(self), local13)
    local17 = local13 and local15
    local18 = input.GetLookInput()
    if input.IsUsingGamePad():
        local19 = math.Clamp01(math.Pow(vector.Length(local18), 1.5))
    else:
        local19 = 1.0
    local20 = vector.Set(local18.x * local19, local18.y * local19, 0.0, 0.0)
    input.DebugInputHistory(local18, local20)
    local21 = vector.Length(local20)
    local22 = input.GetSensitivity()
    local23 = local10
    local24 = 1.5
    local25 = 0.0
    local26 = 1.5
    local27 = 1.5 * 0.8
    if local13:
        local24 = 1.5
        local25 = 0.0
        local26 = 0.5
        local27 = 0.5
    if not input.IsUsingGamePad():
        local26 = 1.1
        local27 = 1.1 * 0.8
        if local13:
            local26 = 0.35
            local27 = 0.35
    if local13 and self.Properties.zoom_fov_current:
        local23 = local23 * (self.Properties.zoom_fov_current / 20.0)
    local28 = math.Lerp(0.12, self.Properties.speed_scale_current, local23)
    if false:
        debug.DrawText(vector.Set(0.05, 0.3, 0.0, 0.0), "speed_scale_current: %f", [local28], lib_color.ORANGE(1.0))
        debug.DrawText(vector.Set(0.05, 0.45, 0.0, 0.0), "auto_aiming: %b", [local15], lib_color.ORANGE(1.0))
    self.Properties.speed_scale_current = local28
    if 1.0 > self.RotationWeight:
        local21 = 0.0
    if local21 > 0.0 and (not local15):
        if input.IsUsingGamePad():
            self.Properties.AccelerationProgress = math.Clamp(self.Properties.AccelerationProgress + local14 * local24, local25, local21)
            local2 = local28 * -local20.x * local22.x * local14 * local26 * self.Properties.AccelerationProgress
            local3 = local28 * -local20.y * local22.y * local14 * local27 * self.Properties.AccelerationProgress
        else:
            local2 = local28 * -local20.x * local22.x * local14 * local26
            local3 = local28 * -local20.y * local22.y * local14 * local27
        self.Properties.do_initial_alignment = false
    else:
        self.Properties.AccelerationProgress = 0.4
    if input.IsUsingGamePad():
        local29 = 15.0
        if local13:
            local29 = 14.0
        if local29 != 0.0:
            local30 = lib_camera.GetDeltaAzElDamped(self, local2, local3, local29, local14)
            local2 = local30[0.0]
            local3 = local30[1.0]
    if false:
        debug.Sphere(self.CameraBaseTransform.r3, 0.03, lib_color.WHITE(0.3))
    if local13:
        local31 = 50.0
        lib_camera.UpdateLeftStickZoom(self, arg1, 5.0, 20.0, local31, local14)
    local32 = self.OffsetAzimuth
    local33 = self.OffsetElevation
    local34 = math.Abs(local32)
    if self.Properties.first_person_aiming_azimuth_threshold > local34:
        if camera.AnyCameraInAnyGroup("driver_aiming"):
            game.SendEventNone("cam.deactivate.shotgun.aim")
            game.SendEventNone("cam.deactivate.harpoon.aim")
    local35 = local4
    if self.Properties.car_transparency_enabled and self.Properties.use_vehicle_fade:
        local36 = local4
        local37 = math.DegToRad(-9.0)
        local38 = math.DegToRad(120.0)
        local39 = math.DegToRad(145.0)
        local40 = character.GetVehicle(character.GetPlayer())
        if local40 != none:
            local41 = -0.25
            if local41 > local33:
                local42 = 0.0
                if local34 > local38:
                    local43 = math.Clamp01(math.Min((local34 - local38) / (local39 - local38), 1.0))
                else:
                    local43 = 0.0
                local44 = math.Scale01(local33, -0.5, local41)
                local45 = math.Clamp01(math.Min(1.0 - local43, local44))
                local45 = math.Scale(local45, 0.0, 1.0, 0.1, 1.0)
                arg1.PlayerVehicleOpacity = local45
                arg1.PlayerOpacity = local45
            else:
                arg1.PlayerVehicleOpacity = 1.0
                arg1.PlayerOpacity = 1.0
    local46 = local3 + local33
    if local46 > local5:
        local46 = local5
        local3 = local5 - local33
    elif local35 > local46:
        local46 = local35
        local3 = local35 - local33
    if false:
        debug.DrawText(vector.Set(0.05, 0.1, 0.0, 0.0), "dEl: %f, currEl: %f, desEl: %f", [local3, local33, local46], lib_color.WHITE(1.0))
        debug.DrawText(vector.Set(0.05, 0.15, 0.0, 0.0), "dAz: %f, currAz: %f", [math.RadToDeg(local2), math.RadToDeg(local32)], lib_color.WHITE(1.0))
    if not local17:
        camera.SetOffsetDeltaOrbit(self, local2, local3)
    local47 = camera.CalculateCameraTransform(self)
    arg1.CameraTransform = local47
