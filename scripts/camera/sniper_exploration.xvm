module sniper_exploration
import @78DDD3EE

def EnterAlignedTransition(self, arg1, arg2):
    lib_camera.AlignAzimuthElevationToSourceCamera(self, arg1, arg2)
    lib_camera.ResetDamping(self)
    Update(self, arg2)

def Init(self):
    self.Properties.TimeSinceInput = 0.0
    self.Properties.SmoothFOV = 50.0

def EnterUnalignedTransition(self, arg1):
    lib_camera.ResetDamping(self)

def Update(self, arg1):
    local2 = 0.0
    local3 = 0.0
    local4 = self.Dt
    local5 = self.Properties.azimuth_dead_zone
    local6 = self.Properties.elevation_dead_zone
    local7 = self.Properties.min_direct_speed
    local8 = self.Properties.max_direct_speed
    local9 = self.Properties.min_top_speed
    local10 = self.Properties.max_top_speed
    local11 = 2.0
    local12 = 0.0
    local13 = 10.0
    local14 = 1.7
    local15 = 1.3
    local16 = 4.0
    local17 = math.DegToRad(self.Properties.min_elevation)
    local18 = math.DegToRad(self.Properties.max_elevation)
    local19 = input.GetLookInput()
    local20 = local19
    input.DebugInputHistory(local19, local20)
    local21 = vector.Length(local20)
    local22 = input.GetSensitivity()
    self.Properties.TimeSinceInput = self.Properties.TimeSinceInput + local4
    if local21 > 0.0:
        self.Properties.TimeSinceInput = 0.0
        self.Properties.AccelerationProgress = math.Clamp(self.Properties.AccelerationProgress + local4 * local11, local12, local21)
        local2 = -local20.x * local22.x * local4 * self.Properties.AccelerationProgress * local8
        local3 = -local20.y * local22.y * local4 * self.Properties.AccelerationProgress * local8
    else:
        self.Properties.AccelerationProgress = 0.0
    if local13 != 0.0:
        local23 = lib_camera.GetDeltaAzElDamped(self, local2, local3, local13, local4)
        local2 = local23[0.0]
        local3 = local23[1.0]
    local24 = self.Properties.TimeSinceInput
    local25 = self.RotationWeight * self.TranslationWeight
    if local24 > local14:
        local26 = local15 * lib_camera.ScaleValue(local24, local14, local14 + local16, 0.0, 1.0) * local25
        local27 = math.DegToRad(180.0)
        local28 = self.InitialOffsetAzimuth
        local29 = self.OffsetAzimuth
        local30 = local28 - local29
        if math.Abs(local30) >= local27:
            if 0.0 > local29:
                local30 = local28 - (2.0 * local27 + local29)
            else:
                local30 = 2.0 * local27 + local28 - local29
        local2 = local30 * local26 * local4
        local31 = self.InitialOffsetElevation
        local32 = self.OffsetElevation
        local33 = local31 - local32
        if math.Abs(local33) >= local27:
            if 0.0 > local32:
                local33 = local31 - (2.0 * local27 + local32)
            else:
                local33 = 2.0 * local27 + local31 - local32
        local3 = local33 * local26 * local4
    local32 = self.OffsetElevation
    local34 = local3 + local32
    if local34 > local18:
        local3 = local18 - local32
    elif local17 > local34:
        local3 = local17 - local32
    local35 = playerstats.GetPlayerStats().FuryMultiplier
    if local35:
        local35 = math.Clamp(local35, 1.0, 15.0)
    else:
        local35 = 1.0
    local36 = arg1.FOV + (local35 - 1.0) * 1.5
    self.Properties.SmoothFOV = self.Properties.SmoothFOV * 0.9 + local36 * 0.1
    local37 = camera.GetInitialOffsetDistance(self)
    local38 = local37 * math.Tan(math.DegToRad(arg1.FOV / 2.0)) / math.Tan(math.DegToRad(self.Properties.SmoothFOV / 2.0)) - (local35 - 1.0) * 0.06
    camera.SetOffsetDistance(self, local38)
    camera.SetOffsetDeltaOrbit(self, local2, local3)
    arg1.CameraTransform = matrix.Mul(self.CameraOffsetTransform, self.CameraBaseTransform)
    arg1.FOV = self.Properties.SmoothFOV
