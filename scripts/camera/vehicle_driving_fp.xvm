module vehicle_driving_fp
import @78DDD3EE

def EnterAlignedTransition(self, arg1, arg2):
    if self.Properties.align_elevation == 0.0:
        lib_camera.AlignAzimuthToSourceCamera(self, arg1, arg2)
    else:
        lib_camera.AlignAzimuthElevationToSourceCameraClamped(self, arg1, arg2, math.DegToRad(self.Properties.min_elevation), math.DegToRad(self.Properties.max_elevation), -math.DegToRad(180.0), math.DegToRad(180.0))
    TransitionReset(self, arg2)
    Update(self, arg2)

def MIN_AZ_BLEND_SPEED():
    return 0.0

def RAM_TARGET_ENUM():
    return 2.0

def Init(self):
    self.Properties.in_camera_reset = false
    self.Properties.in_camera_reset_timer = 0.0
    self.Properties.last_rel_target_pos = vector.Set(0.0, 0.0, 1.0, 0.0)
    self.Properties.time_since_input = 0.0
    self.Properties.AccelerationProgress = 0.0
    self.Properties.onGroundElevation = self.InitialOffsetElevation
    Reset(self)

def AzimuthSpeedLerp(self, arg1, arg2, arg3):
    local4 = AzimuthAngleDiff(self, arg1)
    if local4 > 0.0:
        local5 = math.Min(arg2 * arg3, local4)
    else:
        local5 = math.Max(-arg2 * arg3, local4)
    return ClampAzimuth(self + local5)

def ExitTransition(self, arg1):
    pass

def TETHER_TARGET_ENUM():
    return 1.0

def MAX_AZ_BLEND_SPEED_INITIAL_OFFSET():
    return 8.8

def TransitionReset(self, arg1):
    Reset(self)
    if self.Properties.auto_align_target == CAMP_VISTA_ENUM():
        lib_camera.VistaCameraReset(self, true, arg1)
    self.Properties.azimuth_cursor = self.OffsetAzimuth
    self.Properties.azimuth_blend_speed_cursor = MAX_AZ_BLEND_SPEED_INITIAL_OFFSET()

def EnterUnalignedTransition(self, arg1):
    TransitionReset(self, arg1)
    Update(self, arg1)

def INITIAL_OFFSET_ENUM():
    return 0.0

def CAMP_VISTA_ENUM():
    return 3.0

def AzimuthAngleDiff(self, arg1):
    local2 = arg1 - self
    local3 = math.DegToRad(180.0)
    if math.Abs(local2) >= local3:
        if 0.0 > self:
            local2 = -(local3 + self) - (local3 - arg1)
        else:
            local2 = local3 - self + (local3 + arg1)
    return local2

def ClampAzimuth(self):
    local1 = math.DegToRad(180.0)
    if -local1 > self:
        self = 2.0 * local1 + self
    elif self > local1:
        self = self - 2.0 * local1
    return self

def AzimuthLerp(self, arg1, arg2):
    local3 = AzimuthAngleDiff(arg1, arg2)
    local4 = local3 * self
    return ClampAzimuth(arg1 + local4)

def Reset(self):
    self.Properties.auto_align_active = true
    self.Properties.sustained_input_time = 0.0
    self.Properties.sideram_blend_speed = 0.0
    self.Properties.sideram_active = 0.0
    self.Properties.sideram_side = 0.0
    self.Properties.azimuth_blend_speed_cursor = MIN_AZ_BLEND_SPEED()
    self.Properties.ram_azimuth_anchor = self.OffsetAzimuth
    self.Properties.lastPitch = self.InitialOffsetPitch
    self.Properties.lastRoll = self.InitialOffsetRoll
    lib_camera.ResetDamping(self)

def ClampDelta(self, arg1):
    if self == 0.0:
        return 0.0
    if 0.0 > self:
        arg1 = math.Max(arg1, self)
    else:
        arg1 = math.Min(arg1, self)
    return arg1

def Update(self, arg1):
    local2 = math.DegToRad(180.0)
    if self.Properties.auto_align_target == none:
        self.Properties.auto_align_target = INITIAL_OFFSET_ENUM()
    if self.Properties.align_elevation == none:
        self.Properties.align_elevation = 0.0
    if self.Properties.auto_align_input_threshold_time == none:
        self.Properties.auto_align_input_threshold_time = 0.0
    if self.Properties.auto_elevation_offset == none:
        self.Properties.auto_elevation_offset = 28.0
    if self.Properties.ram_target_max_angle == none:
        self.Properties.ram_target_max_angle = 50.0
    local3 = lib_camera.GetInVehicleCameraCoordinator()
    if local3 != none:
        local4 = scriptgo.GetProperties(local3)
        if local4.forceDrivingCameraReset:
            self.Properties.in_camera_reset = true
            local4.forceDrivingCameraReset = false
    local5 = self.Properties.azimuth_dead_zone
    local6 = self.Properties.elevation_dead_zone
    local7 = self.Properties.min_direct_speed
    local8 = self.Properties.max_direct_speed
    local9 = self.Properties.min_top_speed
    local10 = self.Properties.max_top_speed
    local11 = self.Properties.max_top_speed_mouse
    local12 = self.Properties.acceleration_speed
    local13 = self.Properties.acceleration_clamp
    local14 = self.Properties.auto_align_timer
    if self.Properties.auto_align_blend_speed == none:
        self.Properties.auto_align_blend_speed = 4.0
    local15 = self.Properties.auto_align_blend_speed
    local16 = math.DegToRad(self.Properties.min_elevation)
    local17 = math.DegToRad(self.Properties.max_elevation)
    local18 = 11.0
    local19 = 0.5
    local20 = self.Dt
    local21 = 1000000.0
    if local20 > 0.0:
        local21 = 1.0 / local20
    local22 = character.GetVehicle(character.GetPlayer())
    local23 = input.GetLookInput()
    local24 = vector.Length(local23)
    self.Properties.time_since_input = self.Properties.time_since_input + local20
    if local24 > 0.0:
        self.Properties.time_since_input = 0.0
        self.Properties.sustained_input_time = self.Properties.sustained_input_time + local20
        self.Properties.azimuth_blend_speed_cursor = MIN_AZ_BLEND_SPEED()
        self.Properties.AccelerationProgress = math.Clamp(self.Properties.AccelerationProgress + local20 * local12, local13, local24)
    else:
        self.Properties.sustained_input_time = 0.0
        self.Properties.AccelerationProgress = 0.0
    if self.Properties.auto_align_input_threshold_time > 0.0 and self.Properties.sustained_input_time > self.Properties.auto_align_input_threshold_time:
        self.Properties.auto_align_active = false
    local25 = self.Properties.time_since_input
    local26 = input.GetSensitivity()
    if input.IsUsingGamePad():
        local27 = -local23.x * local26.x * local20 * self.Properties.AccelerationProgress * local10
        local28 = -local23.y * local26.y * local20 * self.Properties.AccelerationProgress * local10
    else:
        local27 = -local23.x * local26.x * local20 * local11
        local28 = -local23.y * local26.y * local20 * local11
    if input.IsUsingGamePad():
        if 15.0 != 0.0:
            local29 = lib_camera.GetDeltaAzElDamped(self, local27, local28, 15.0, local20)
            local27 = local29[0.0]
            local28 = local29[1.0]
    local30 = none
    if self.Properties.auto_align_target == TETHER_TARGET_ENUM():
        local31 = lib_entity_proxy.GetHarpoon(vehicle.GetSignatureVehicle())
        local30 = scriptgo.Call(local31, @0C537298)
        if local30 == none:
            local30 = vector.Add(self.CameraBaseTransform.r3, self.Properties.last_rel_target_pos)
        else:
            self.Properties.last_rel_target_pos = vector.Sub(local30, self.CameraBaseTransform.r3)
    elif self.Properties.auto_align_target == RAM_TARGET_ENUM():
        local3 = lib_camera.GetInVehicleCameraCoordinator()
        local32 = scriptgo.Call(local3, @B0E57FF6)
        if local32 != none:
            local30 = game.GetTransform(local32).r3
    elif self.Properties.auto_align_target == CAMP_VISTA_ENUM():
        if lib_camera.UpdateVistaCam(self, arg1, local24, true, local20):
            return
    local22 = character.GetVehicle(character.GetPlayer())
    local33 = false
    if self.Properties.in_camera_reset:
        self.Properties.in_camera_reset_timer = self.Properties.in_camera_reset_timer + local20
        local34 = self.InitialOffsetAzimuth
        local35 = self.OffsetAzimuth
        local36 = local34 - local35
        if math.Abs(local36) >= local2:
            if 0.0 > local35:
                local36 = local34 - (2.0 * local2 + local35)
            else:
                local36 = 2.0 * local2 + local34 - local35
        local37 = self.InitialOffsetElevation
        local38 = self.OffsetElevation
        local39 = local37 - local38
        if math.Abs(local39) >= local2:
            if 0.0 > local38:
                local39 = local37 - (2.0 * local2 + local38)
            else:
                local39 = 2.0 * local2 + local37 - local38
        if (math.Abs(local36) > 0.05 or math.Abs(local39) > 0.05) and local19 > self.Properties.in_camera_reset_timer:
            local27 = local36 * local18 * local20
            local28 = local39 * local18 * local20
        else:
            self.Properties.in_camera_reset = false
    else:
        self.Properties.in_camera_reset_timer = 0.0
        if local30 == none:
            local40 = false
            if local22:
                local41 = vehicle.GetLocalVelocity(local22)
                if local41.z > 0.0:
                    local40 = true
        if false:
            debug.DrawText(vector.Set(0.1, 0.05, 0.0, 0.0), "backward: %b input: %f time_since_input: %f", [local40, local24, local25], lib_color.WHITE(1.0))
        if (not local40) and local24 == 0.0 and local25 > local14 and self.Properties.auto_align_active:
            local39 = 0.0
            local42 = local15
            local43 = 0.0
            local44 = self.OffsetAzimuth
            if self.Properties.auto_align_target == CAMP_VISTA_ENUM():
                pass
            elif self.Properties.auto_align_target == INITIAL_OFFSET_ENUM():
                local45 = matrix.Inverse(self.CameraBaseTransform)
                local46 = vector.Scale(vehicle.GetLocalVelocity(local22), -1.0)
                local47 = vector.Clone(local46)
                local47.y = 0.0
                local48 = vector.Length(local47)
                local49 = 1.0
                if local48 > local49:
                    local44 = 0.0
                    local50 = MAX_AZ_BLEND_SPEED_INITIAL_OFFSET()
                    self.Properties.azimuth_cursor = AzimuthSpeedLerp(self.Properties.azimuth_cursor, ClampAzimuth(local44), math.DegToRad(180.0), local20)
                    local44 = self.Properties.azimuth_cursor
                    local39 = self.InitialOffsetElevation - self.OffsetElevation
                    self.Properties.azimuth_blend_speed_cursor = math.SpeedLerp(self.Properties.azimuth_blend_speed_cursor, local50, 1.0, local20)
                    local42 = self.Properties.azimuth_blend_speed_cursor
                else:
                    local50 = MIN_AZ_BLEND_SPEED()
                    self.Properties.azimuth_blend_speed_cursor = math.SpeedLerp(self.Properties.azimuth_blend_speed_cursor, local50, 1.0, local20)
                    local42 = self.Properties.azimuth_blend_speed_cursor
                    local44 = self.Properties.azimuth_cursor
                if vehicle.GetSideRamAttackEnabled(local22):
                    local51 = vehicle.GetSideRamAttackSide(local22)
                    if self.Properties.sideram_side != local51 or 0.0 >= self.Properties.sideram_active:
                        self.Properties.sideram_active = 0.9
                        self.Properties.sideram_side = vehicle.GetSideRamAttackSide(local22)
                        self.Properties.sideram_blend_speed = 0.0
                if self.Properties.sideram_active > 0.0:
                    self.Properties.sideram_active = self.Properties.sideram_active - local20
                    self.Properties.sideram_blend_speed = math.SpeedLerp(self.Properties.sideram_blend_speed, 7.0, 8.0, local20)
                    local42 = self.Properties.sideram_blend_speed
                    local52 = 0.9
                    local44 = local44 + self.Properties.sideram_side * local52
                elif self.Properties.sideram_blend_speed > 0.0:
                    self.Properties.sideram_blend_speed = math.SpeedLerp(self.Properties.sideram_blend_speed, 0.0, 5.0, local20)
                    local42 = 7.0 - self.Properties.sideram_blend_speed
                if false:
                    local53 = lib_color.WHITE(1.0)
                    debug.DrawText(vector.Set(0.1, 0.1, 0.0, 0.0), "Sideram time: %f blend_speed: %f", [self.Properties.sideram_active, self.Properties.sideram_blend_speed], local53)
            elif local30 != none:
                if 1.0 == self.TranslationWeight:
                    local54 = 0.5
                    local55 = lib_camera.GetAzElTowardsPos(self, arg1, local30, local54)
                    if false:
                        debug.Sphere(local30, 3.0, lib_color.WHITE(0.3))
                    if local55:
                        local44 = local55[0.0]
                        local56 = local55[1.0] + math.DegToRad(self.Properties.auto_elevation_offset)
                        local39 = local56 - self.OffsetElevation
                        local33 = true
                        if false:
                            local53 = lib_color.WHITE(1.0)
                            debug.DrawText(vector.Set(0.1, 0.1, 0.0, 0.0), "Az: %f El: %f (dEl:%f)", [local55[0.0], local55[1.0], local39], local53)
                "\n              "
            local35 = self.OffsetAzimuth
            local36 = AzimuthAngleDiff(local35, local44)
            local57 = local36 * local42 + math.Sign(local36) * local43
            if math.Abs(local57 * local20) > math.Abs(local36):
                local57 = local36 / local20
            local58 = local39 * local42 + math.Sign(local39) * local43
            if math.Abs(local58 * local20) > math.Abs(local39):
                local58 = local39 / local20
            local27 = ClampDelta(local36, local57 * local20)
            local28 = ClampDelta(local39, local58 * local20)
            if false:
                local53 = lib_color.WHITE(1.0)
                debug.DrawText(vector.Set(0.1, 0.15, 0.0, 0.0), "dAz: %f dEl: %f", [local27, local28], local53)
    local38 = self.OffsetElevation
    local59 = 0.0
    if local22:
        local59 = vehicle.GetWheelContactRatio(local22)
    self.Properties.onGroundElevation = local38
    local60 = math.Clamp(local28 + local38, local16, local17)
    local28 = local60 - local38
    camera.SetOffsetDeltaOrbit(self, local27, local28)
    if not local33:
        local61 = self.OffsetPitch
        local62 = vector.Set(0.0, 1.0, 0.0, 0.0)
        local63 = vector.Clone(self.CameraBaseTransform.r1)
        local63.x = 0.0
        local63 = vector.Normalize(local63)
        local64 = vector.AngleBetween(local62, local63)
        local65 = math.Lerp(0.7, local61, local64)
        local66 = local65 - local61
        self.Properties.lastPitch = local65
        if 0.01 > math.Abs(local66):
            local66 = 0.0
        local67 = self.OffsetRoll
        local63 = vector.Clone(self.CameraBaseTransform.r1)
        local63.z = 0.0
        local63 = vector.Normalize(local63)
        local68 = vector.AngleBetween(local62, local63)
        local69 = math.Lerp(0.4, local67, local68)
        local70 = local69 - local67
        self.Properties.lastRoll = local69
        if 0.01 > math.Abs(local70):
            local70 = 0.0
        if false:
            local53 = lib_color.WHITE(1.0)
            debug.DrawText(vector.Set(0.1, 0.2, 0.0, 0.0), "pitch: %f delta_pitch: %f", [local64, local66], local53)
            debug.DrawText(vector.Set(0.1, 0.3, 0.0, 0.0), "roll: %f delta_roll: %f", [local68, local70], local53)
        camera.SetOffsetDeltaYawPitchRoll(self, 0.0, local66, 0.0)
    arg1.CameraTransform = matrix.Mul(self.CameraOffsetTransform, self.CameraBaseTransform)
