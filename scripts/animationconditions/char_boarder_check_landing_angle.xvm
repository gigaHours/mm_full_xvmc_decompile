module char_boarder_check_landing_angle

def Evaluate(self, arg1):
    local2 = vehicle.GetGlobalProperties()
    local3 = false or local2.BoardingLandDebugEnabled
    local4 = 4.0
    local5 = 75.0
    local6 = -0.05
    if arg1.Property0 > 1.5:
        local5 = 120.0
        local6 = -0.24
    elif arg1.Property0 > 0.5:
        local5 = 85.0
        local6 = -0.19
    local7 = character.GetInteractionUserProxy(self)
    local8 = interaction.GetEntryNodeTransform(local7, local4)
    if none != local8:
        local9 = character.GetWorldMatrix(self)
        local10 = local9.r3
        local11 = local8.r3
        local12 = local9.r2
        local13 = vector.Sub(local10, local11)
        local13.y = 0.0
        if vector.Length(local13):
            local13 = vector.Normalize(local13)
        else:
            local13 = vector.Scale(local9.r2, -1.0)
        local14 = local8.r2
        local15 = vector.Dot(local14, local12)
        local16 = math.RadToDeg(vector.AngleBetween(local14, local13))
        if local3:
            debug.Arrow(local11, vector.Add(local11, vector.Scale(local13, 2.0)), 0.1, lib_color.YELLOW(0.5))
            debug.Arrow(local11, vector.Add(local11, vector.Scale(local14, 2.0)), 0.1, lib_color.MAGENTA(0.5))
            debug.LogInfo("Boarder Landing Check (limit)--- AngleFwd: %f(max %f), dotCharFwd: %f(min %f)", [local16, local5, local15, local6])
        if local5 > local16 and local15 > local6:
            if local3:
                debug.Sphere(local11, 0.6, lib_color.GREEN(0.2))
            return 1.0
        if local3:
            debug.Sphere(local11, 0.4, lib_color.ORANGE(0.2))
    return 0.0
